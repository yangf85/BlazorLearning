# BlazorLearning 学习进度记录

## 项目概述
- **项目名称**：BlazorLearning
- **学习目标**：掌握Blazor权限框架开发
- **技术栈**：ASP.NET Core Web API + FreeSql + PostgreSQL + Blazor
- **开始时间**：2025年6月26日

## 整体学习路线（加速版）

### 🎯 阶段一：后端API基础（3-4天）
**目标**：搭建完整的Web API后端 + FreeSql + PostgreSQL

### 🔐 阶段二：认证授权基础（3-4天）
**目标**：实现JWT认证和角色权限

### 🖥️ 阶段三：Blazor前端开发（5-6天）
**目标**：创建完整的Blazor权限应用

### 📊 阶段四：权限框架完善（3-4天）
**目标**：高级权限功能和优化

### 🚀 阶段五：项目部署（1-2天）
**目标**：容器化部署

**总计**：15-20天完成整个权限框架学习

---

## 详细进度跟踪

### 阶段一：后端API基础（Day 1-4）
**开始时间**：2025年6月26日  
**预计完成**：2025年6月29日  
**实际完成**：_待填写_

#### Day 1：项目搭建 + 基础API ✅ **已完成**
- [x] 创建BlazorLearning解决方案 - 2025/6/26
- [x] 创建BlazorLearning.Api项目 - 2025/6/26
- [x] 配置Scalar API文档界面 - 2025/6/26
- [x] 创建User模型和基础Controller - 2025/6/26
- [x] 实现GET用户列表接口 - 2025/6/26
- [x] 实现GET单个用户接口 - 2025/6/26
- [x] 测试API接口正常工作 - 2025/6/26

#### Day 2：FreeSql + PostgreSQL集成 ✅ **已完成**
- [x] 安装FreeSql.Provider.PostgreSQL包 - 2025/6/27
- [x] 配置PostgreSQL连接和FreeSql - 2025/6/27
- [x] 创建User实体和表结构 - 2025/6/27
- [x] 实现Repository模式 - 2025/6/27
- [x] 完成用户CRUD操作 - 2025/6/27

#### Day 3：数据验证和错误处理
- [ ] 添加模型验证（Data Annotations）
- [ ] 实现全局异常处理中间件
- [ ] 添加日志记录
- [ ] API响应格式统一
- [ ] 完善Swagger文档注释

#### Day 4：准备认证基础
- [ ] 设计用户认证相关表结构
- [ ] 创建角色（Role）实体
- [ ] 实现密码加密工具类
- [ ] 准备JWT配置

### 阶段二：认证授权基础（Day 5-8）
**开始时间**：2025年6月30日  
**预计完成**：2025年7月3日  
**实际完成**：_待填写_

#### Day 5：JWT认证实现
- [ ] 安装JWT相关包
- [ ] 配置JWT认证服务
- [ ] 实现用户注册API
- [ ] 实现登录API（返回JWT Token）
- [ ] 测试Token验证

#### Day 6：角色权限系统
- [ ] 创建角色管理API
- [ ] 实现用户角色分配
- [ ] 添加基于角色的API权限控制
- [ ] 学习Claims和Policy授权
- [ ] 创建权限验证特性

#### Day 7：权限细化
- [ ] 设计权限表结构（菜单权限、操作权限）
- [ ] 实现动态权限分配
- [ ] 创建权限验证中间件
- [ ] 测试不同角色的API访问

#### Day 8：认证优化
- [ ] 实现Token刷新机制
- [ ] 添加登录状态记录
- [ ] 优化密码安全策略
- [ ] 完善认证相关API文档

### 阶段三：Blazor前端开发（Day 9-14）
**开始时间**：2025年7月4日  
**预计完成**：2025年7月9日  
**实际完成**：_待填写_

#### Day 9：Blazor项目创建
- [ ] 创建BlazorLearning.Web项目
- [ ] 配置HttpClient和API基础URL
- [ ] 创建基础布局和导航组件
- [ ] 实现路由配置

#### Day 10：API集成和数据展示
- [ ] 创建API服务类
- [ ] 实现用户列表页面
- [ ] 添加数据加载状态处理
- [ ] 实现用户详情页面

#### Day 11：表单和CRUD操作
- [ ] 创建用户添加/编辑表单
- [ ] 实现客户端验证
- [ ] 添加成功/错误提示组件
- [ ] 完成用户管理完整功能

#### Day 12：认证集成
- [ ] 实现登录/注册页面
- [ ] 集成JWT Token到Blazor
- [ ] 配置AuthenticationStateProvider
- [ ] 实现自动Token刷新

#### Day 13：权限控制
- [ ] 实现路由权限保护
- [ ] 创建权限验证组件
- [ ] 添加动态菜单显示
- [ ] 实现按钮级权限控制

#### Day 14：前端优化
- [ ] 添加Loading组件
- [ ] 优化错误处理和用户体验
- [ ] 实现退出登录功能
- [ ] 前端权限缓存优化

### 阶段四：权限框架完善（Day 15-18）
**开始时间**：2025年7月10日  
**预计完成**：2025年7月13日  
**实际完成**：_待填写_

#### Day 15：权限管理界面
- [ ] 创建角色管理页面
- [ ] 实现权限分配界面
- [ ] 添加用户角色管理功能
- [ ] 创建权限树组件

#### Day 16：高级权限功能
- [ ] 实现权限继承和组合
- [ ] 添加操作日志记录
- [ ] 创建权限变更通知机制
- [ ] 实现权限缓存策略

#### Day 17：系统优化
- [ ] 性能优化（数据库查询、前端渲染）
- [ ] 安全加固（SQL注入防护、XSS防护）
- [ ] 添加API限流功能
- [ ] 完善错误处理和日志

#### Day 18：功能完善
- [ ] 添加用户在线状态管理
- [ ] 实现多设备登录控制
- [ ] 创建系统设置页面
- [ ] 完善帮助文档和使用说明

### 阶段五：项目部署（Day 19-20）
**开始时间**：2025年7月14日  
**预计完成**：2025年7月15日  
**实际完成**：_待填写_

#### Day 19：容器化和部署准备
- [ ] 编写Dockerfile
- [ ] 配置docker-compose（API + PostgreSQL）
- [ ] 准备生产环境配置
- [ ] 数据库迁移脚本

#### Day 20：部署和测试
- [ ] 部署到云服务器或本地Docker
- [ ] 配置反向代理（Nginx）
- [ ] 性能测试和安全测试
- [ ] 编写部署文档

---

## 里程碑检查点（加速版）

### ✅ 里程碑1（Day 4）：后端API完成
- [ ] FreeSql + PostgreSQL正常工作
- [ ] 完整的用户CRUD API
- [ ] 基本的数据验证和错误处理

### ✅ 里程碑2（Day 8）：认证系统完成
- [ ] JWT认证机制正常工作
- [ ] 用户注册登录功能完善
- [ ] 基于角色的API权限控制

### ✅ 里程碑3（Day 14）：Blazor应用完成
- [ ] Blazor前端应用正常运行
- [ ] 前后端认证集成成功
- [ ] 完整的权限控制功能

### ✅ 里程碑4（Day 18）：权限系统完成
- [ ] 完整的权限管理界面
- [ ] 高级权限功能实现
- [ ] 系统性能和安全性优化

### ✅ 里程碑5（Day 20）：项目部署完成
- [ ] 成功容器化部署
- [ ] 生产环境正常运行
- [ ] 完整的项目文档

---

## 技术栈详细信息

### 后端技术
- **框架**：ASP.NET Core 9.0 Web API
- **ORM**：FreeSql
- **数据库**：PostgreSQL
- **认证**：JWT + ASP.NET Core Identity
- **文档**：OpenAPI + Scalar

### 前端技术
- **框架**：Blazor Server 或 Blazor WebAssembly
- **UI组件**：待定（Bootstrap/Ant Design Blazor/MudBlazor）
- **状态管理**：内置状态管理
- **HTTP客户端**：HttpClient

### 开发工具
- **IDE**：Visual Studio 2022
- **数据库工具**：pgAdmin 4
- **版本控制**：Git + GitHub
- **容器化**：Docker

---

## 代码提交规范

### Commit Message格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

### Type类型
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档修改
- `style`: 代码格式修改
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

### 示例
```
feat(auth): 添加JWT认证功能

- 实现JWT Token生成和验证
- 添加登录API端点
- 集成ASP.NET Core Identity

Closes #123
```

---

## 学习资源

### 官方文档
- [ASP.NET Core文档](https://docs.microsoft.com/aspnet/core)
- [Blazor文档](https://docs.microsoft.com/aspnet/core/blazor)
- [FreeSql文档](https://freesql.net/)

### 推荐教程
- [ASP.NET Core Web API教程](https://docs.microsoft.com/learn/paths/create-web-api-with-aspnet-core/)
- [Blazor入门教程](https://docs.microsoft.com/learn/paths/build-web-apps-with-blazor/)

### 社区资源
- [Stack Overflow](https://stackoverflow.com/questions/tagged/blazor)
- [ASP.NET Core GitHub](https://github.com/dotnet/aspnetcore)

---

## 问题记录和解决方案

### Day 1 问题汇总（2025年6月26日）

<details>
<summary>1. OpenAPI配置和调试接口工具选择</summary>

**问题描述**：如何配置 .NET 9 WebAPI 的接口调试工具，Scalar和Swagger UI有什么区别

**解决方案**：
选择Scalar作为API文档工具的完整配置：
- 安装命令：`dotnet add package Scalar.AspNetCore`
- Program.cs中添加OpenAPI和Scalar配置
- Scalar相比Swagger UI更现代化，界面更美观
- 支持多种主题和更好的代码生成功能
- 基于同样的OpenAPI规范，功能兼容

**具体配置对比**：
```csharp
// Scalar配置（推荐）
app.MapOpenApi();
app.MapScalarApiReference(options =>
{
    options.WithTitle("我的 API 文档")
           .WithTheme(ScalarTheme.BluePlanet);
});

// Swagger UI配置（传统）
app.UseSwaggerUI(options =>
{
    options.SwaggerEndpoint("/openapi/v1.json", "v1");
});
```

**学习要点**：
- .NET 9推荐使用内置OpenAPI而不是Swashbuckle
- Scalar是微软推荐的现代API文档解决方案
- 两者都基于OpenAPI 3.0规范，数据源相同
- 选择工具时考虑用户体验和维护成本
</details>

<details>
<summary>2. 浏览器自动启动和路径配置</summary>

**问题描述**：每次启动项目都需要手动输入URL访问API文档，影响开发效率

**解决方案**：
通过launchSettings.json配置开发环境自动启动：
- 找到Properties/launchSettings.json文件
- 设置`"launchBrowser": true`启用自动浏览器
- 配置`"launchUrl": "scalar/v1"`指定默认页面
- 确保applicationUrl配置正确

**配置示例**：
```json
{
  "profiles": {
    "https": {
      "commandName": "Project",
      "launchBrowser": true,
      "launchUrl": "scalar/v1",
      "applicationUrl": "https://localhost:7157",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
```

**学习要点**：
- launchSettings.json只影响开发环境，不会打包到生产环境
- 不同profile可以配置不同的启动行为
- launchUrl是相对于applicationUrl的路径
- 合理配置可以显著提高开发效率
</details>

<details>
<summary>3. API文档访问路径和根路径重定向问题</summary>

**问题描述**：访问`https://localhost:7157/`显示404，不知道正确的API文档路径

**解决方案**：
理解不同API文档工具的默认路径约定：
- Scalar默认路径：`/scalar/v1`
- Swagger UI默认路径：`/swagger`
- OpenAPI JSON规范：`/openapi/v1.json`
- 根路径默认为空，需要手动配置内容

**路径重定向配置**：
```csharp
// 方案1：根路径重定向到Scalar
app.MapGet("/", () => Results.Redirect("/scalar/v1"));

// 方案2：显示简单欢迎页面
app.MapGet("/", () => "欢迎使用 BlazorLearning API！请访问 /scalar/v1 查看文档");
```

**学习要点**：
- 不同文档工具有各自的路径约定，需要了解并记住
- 根路径（/）需要开发者主动配置，ASP.NET Core不提供默认页面
- 合理的路径设计能提升API的可发现性
- 生产环境可能需要隐藏或保护API文档路径
</details>

<details>
<summary>4. Controller控制器的作用和MVC架构理解</summary>

**问题描述**：作为新手不理解Controller是用来干什么的，为什么需要这个概念

**解决方案**：
Controller是Web API中的核心概念，理解其作用：
- **职责**：Controller相当于"服务窗口"或"接待员"
- **功能**：接收HTTP请求，处理业务逻辑，返回HTTP响应
- **组织**：一个Controller通常管理一类资源（如用户、订单、产品）
- **方法**：Controller中的方法对应具体的业务操作

**实际类比理解**：
```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    // 相当于银行的"查询余额"窗口
    [HttpGet]
    public ActionResult<IEnumerable<User>> GetUsers()
    
    // 相当于银行的"开户"窗口
    [HttpPost]
    public ActionResult CreateUser(User user)
    
    // 相当于银行的"修改信息"窗口
    [HttpPut("{id}")]
    public ActionResult UpdateUser(int id, User user)
}
```

**学习要点**：
- Controller是RESTful API设计的基础概念
- 一个Controller = 一类业务资源的管理中心
- HTTP方法（GET/POST/PUT/DELETE）对应CRUD操作
- 良好的Controller设计让API结构清晰易懂
</details>

<details>
<summary>5. Route路由特性和URL构建机制</summary>

**问题描述**：`[Route("api/[controller]")]`中的`[controller]`是什么特殊语法

**解决方案**：
Route特性使用智能占位符系统：
- `[controller]`是ASP.NET Core的智能占位符
- 自动替换为控制器类名（去掉Controller后缀）
- 支持自动化和重构友好的URL设计

**占位符替换规则**：
```csharp
// UsersController → "users"
// ProductsController → "products"  
// OrdersController → "orders"

[Route("api/[controller]")]        // 基础路由模板
public class UsersController : ControllerBase
{
    [HttpGet]                      // GET /api/users
    [HttpGet("{id}")]              // GET /api/users/1
    [HttpPost]                     // POST /api/users
    [HttpPut("{id}")]              // PUT /api/users/1
    [HttpDelete("{id}")]           // DELETE /api/users/1
}
```

**路由构建原理**：
1. ASP.NET Core读取Route特性
2. 解析占位符并替换为实际值
3. 结合HTTP方法特性构建完整路由表
4. 运行时根据请求URL匹配对应的Controller方法

**学习要点**：
- 占位符机制让路由配置更加灵活和一致
- 约定优于配置（Convention over Configuration）设计理念
- 重构类名时路由会自动更新，避免手动维护
- 理解路由构建有助于设计RESTful API
</details>

<details>
<summary>6. Scalar界面API接口测试操作流程</summary>

**问题描述**：不熟悉如何在Scalar界面中测试API接口，不知道具体操作步骤

**解决方案**：
Scalar提供完整的API测试功能，操作流程：

**测试步骤详解**：
1. **访问文档**：启动项目后访问`https://localhost:7157/scalar/v1`
2. **选择接口**：在左侧API列表中点击要测试的接口
3. **查看详情**：右侧显示接口的详细信息（参数、请求体、响应格式）
4. **填写参数**：根据接口要求填写路径参数、查询参数或请求体
5. **发送请求**：点击"Send Request"或"Execute"按钮
6. **查看结果**：观察HTTP状态码、响应头和响应体内容

**具体测试案例**：
```
测试用例1：GET /api/users
- 无需参数，直接点击执行
- 预期：200状态码 + 用户列表JSON

测试用例2：GET /api/users/{id}
- 在id参数框输入：1、2、3
- 预期：200状码 + 单个用户JSON（存在时）
- 预期：404状态码（不存在时，如id=999）

测试用例3：POST /api/users  
- 在请求体中输入用户JSON数据
- 预期：201状态码 + 创建成功的用户数据
```

**状态码理解**：
- 200 OK：请求成功
- 201 Created：资源创建成功  
- 400 Bad Request：请求参数错误
- 404 Not Found：资源不存在
- 500 Internal Server Error：服务器内部错误

**学习要点**：
- Scalar界面比Postman等工具更直观，因为基于API文档
- 实时测试帮助验证API设计和实现的正确性
- 观察状态码和响应内容是调试API的基本技能
- 测试不同参数组合有助于发现边界条件问题
</details>

### 学习心得总结

**Day 1 主要成就**：
- ✅ 成功搭建了 ASP.NET Core 9.0 Web API 项目
- ✅ 配置了现代化的 Scalar API 文档工具
- ✅ 创建了基础的用户管理 API（GET 操作）
- ✅ 理解了 Controller、Route、HTTP 方法等核心概念
- ✅ 掌握了使用 Scalar 测试 API 的方法

**关键知识点**：
1. .NET 9 推荐使用 OpenAPI 而不是传统 Swagger
2. Scalar 是比 Swagger UI 更现代的 API 文档工具
3. Controller 是 Web API 的"服务窗口"
4. Route 特性中的 `[controller]` 是智能占位符
5. `launchSettings.json` 控制开发环境行为

**下一步计划**：
明天开始 Day 2：FreeSql + PostgreSQL 集成，将模拟数据替换为真实数据库操作。

### Day 2 问题汇总（2025年6月27日）

<details>
<summary>1. FreeSql自动创建数据库的误解</summary>

**问题描述**：以为FreeSql能自动创建数据库

**解决方案**：
- FreeSql只能自动同步表结构，不能创建数据库本身
- 需要手动创建数据库（使用HeidiSQL、pgAdmin或psql命令行）
- 创建数据库后FreeSql会自动创建和维护表结构

**学习要点**：
- UseAutoSyncStructure(true)只同步表结构
- 数据库需要预先存在
- 连接字符串中的数据库名必须是已存在的数据库
</details>

<details>
<summary>2. Repository模式的生命周期选择</summary>

**问题描述**：为什么Repository注册为Scoped而不是Singleton

**解决方案**：
Repository使用Scoped的原因：
- 每个HTTP请求有独立的Repository实例，避免并发冲突
- 支持事务操作的隔离性
- 平衡性能和内存使用

**对比理解**：
- FreeSql使用Singleton：数据库连接池全局共享
- Repository使用Scoped：请求级别的数据操作隔离

**学习要点**：
- 理解三种依赖注入生命周期的适用场景
- Repository模式的最佳实践选择
</details>

<details>
<summary>3. FreeSql配置服务化的最佳实践</summary>

**问题描述**：如何优雅地配置FreeSql服务

**解决方案**：
- 创建ServiceCollectionExtensions扩展类
- 封装FreeSql配置逻辑到AddFreeSqlService方法
- 统一管理FreeSql和Repository的服务注册

**学习要点**：
- 服务配置模块化，提高代码可维护性
- 扩展方法的使用和命名约定
- 依赖注入的组织和管理
</details>

<details>
<summary>4. PUT接口的参数验证和错误处理</summary>

**问题描述**：PUT请求时出现400 Bad Request错误

**解决方案**：
常见PUT请求问题及解决：
- 确保URL路径参数有具体值
- URL中的ID必须与请求体中的ID一致
- 避免在请求体中包含自动生成的字段（如CreatedAt、UpdatedAt）

**学习要点**：
- PUT请求的参数一致性验证重要性
- 客户端不应传递服务端自动管理的字段
- API错误调试的方法和思路
</details>

<details>
<summary>5. 软删除机制的实现</summary>

**问题描述**：如何实现数据的软删除

**解决方案**：
软删除实现要点：
- 使用IsActive字段标记数据状态
- 删除操作实际是Update操作，设置IsActive=false
- 所有查询自动过滤IsActive=false的数据

**学习要点**：
- 软删除保持数据完整性和可追溯性
- 业务查询需要统一考虑软删除过滤
- 为将来的数据恢复功能留下可能
</details>

### 学习心得总结

**Day 2 主要成就**：
- ✅ 成功搭建了FreeSql + PostgreSQL的数据访问层
- ✅ 实现了标准的Repository模式
- ✅ 完成了完整的用户CRUD操作
- ✅ 掌握了软删除的实现机制
- ✅ 理解了依赖注入的生命周期管理

**关键技术突破**：
1. FreeSql的配置和基本用法
2. Repository模式的最佳实践
3. RESTful API的标准实现
4. 软删除机制的设计思路
5. 依赖注入服务的生命周期选择

**代码质量提升**：
- 服务配置模块化（Extensions模式）
- 接口与实现分离
- 异常处理和错误返回
- 代码注释和文档完善

**下一步计划**：
明天开始 Day 3：数据验证和错误处理，将进一步完善API的健壮性和用户体验。

---

## 项目展示

### 功能截图
_项目完成后添加功能截图_

### 在线演示
_部署完成后添加演示链接_

### 代码仓库
- **GitHub**：_添加仓库链接_

---

**最后更新时间**：2025年6月27日  
**当前阶段**：阶段一 - Day 2 FreeSql集成（已完成）  
**总体进度**：2/20天 (10%) → **完成 Day 2**